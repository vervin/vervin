(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{613:function(n,s,a){"use strict";a.r(s);var t=a(8),e=Object(t.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"柯里化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[n._v("#")]),n._v(" 柯里化")]),n._v(" "),a("p",[n._v("在数学和计算机科学中，柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\n")]),n._v(" "),a("p",[n._v("用大白话来说就是只传递给函数一部分参数来调用它，让它返回一个新函数去处理剩下的参数。使用一个简单的例子来介绍下，最常用的就是 add 函数了。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// add\nconst add = (...args) => args.reduce((a, b) => a + b);\n\n// 传入多个参数，执行 add 函数\nadd(1, 2) // 3\n\n// 假设我们实现了一个 currying 函数，支持一次传入一个参数\nlet sum = currying(add);\n// 封装第一个参数，方便重用\nlet addCurryOne = sum(1);\naddCurryOne(2) // 3\naddCurryOne(3) // 4\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("h2",{attrs:{id:"实际应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实际应用"}},[n._v("#")]),n._v(" 实际应用")]),n._v(" "),a("h3",{attrs:{id:"_1、延迟计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、延迟计算"}},[n._v("#")]),n._v(" 1、延迟计算")]),n._v(" "),a("p",[n._v("我们看下面的部分求和例子，很好的说明了延迟计算这个情况。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const add = (...args) => args.reduce((a, b) => a + b);\n\n// 简化写法\nfunction currying(func) {\n    const args = [];\n    return function result(...rest) {\n        if (rest.length === 0) {\n          return func(...args);\n        } else {\n          args.push(...rest);\n        \treturn result;\n        }\n    }\n}\n\nconst sum = currying(add);\n\nsum(1,2)(3); // 未真正求值\nsum(4); \t\t // 未真正求值\nsum(); \t\t\t // 输出 10\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br")])]),a("p",[n._v("上面的代码理解起来很容易，就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面的 currying 函数是一种简化写法，判断传入的参数长度是否为 0，若为 0 执行函数，否则收集参数。")]),n._v(" "),a("p",[n._v("另一种常见的应用是 bind 函数，我们看下 bind 的使用。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let obj = {\n  name: 'muyiy'\n}\nconst fun = function () {\n  console.log(this.name);\n}.bind(obj);\n\nfun(); // muyiy\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br")])]),a("p",[n._v("这里 bind 用来改变函数执行时候的上下文，但是函数本身并不执行，所以本质上是延迟计算，这一点和 call / apply 直接执行有所不同。")]),n._v(" "),a("p",[n._v("我们看下 bind 模拟实现，其本身就是一种柯里化，我们在最后的实现部分会发现，bind 的模拟实现和柯理化函数的实现，其核心代码都是一致的。")]),n._v(" "),a("p",[n._v("以下实现方案是简化版实现，完整版实现过程和代码解读请看我之前写的一篇文章，【进阶3-4期】深度解析bind原理、使用场景及模拟实现。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 简化实现，完整版实现中的第 2 步\nFunction.prototype.bind = function (context) {\n    var self = this;\n    // 第 1 个参数是指定的 this，截取保存第 1 个之后的参数\n\t\t// arr.slice(begin); 即 [begin, end]\n    var args = Array.prototype.slice.call(arguments, 1); \n\n    return function () {\n        // 此时的 arguments 是指 bind 返回的函数调用时接收的参数\n        // 即 return function 的参数，和上面那个不同\n      \t// 类数组转成数组\n        var bindArgs = Array.prototype.slice.call(arguments);\n      \t// 执行函数\n        return self.apply( context, args.concat(bindArgs) );\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br")])]),a("h3",{attrs:{id:"_2、动态创建函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、动态创建函数"}},[n._v("#")]),n._v(" 2、动态创建函数")]),n._v(" "),a("p",[n._v("有一种典型的应用情景是这样的，每次调用函数都需要进行一次判断，但其实第一次判断计算之后，后续调用并不需要再次判断，这种情况下就非常适合使用柯里化方案来处理。即第一次判断之后，动态创建一个新函数用于处理后续传入的参数，并返回这个新函数。当然也可以使用惰性函数来处理，本例最后一个方案会有所介绍。")]),n._v(" "),a("p",[n._v("我们看下面的这个例子，在 DOM 中添加事件时需要兼容现代浏览器和 IE 浏览器（IE < 9），方法就是对浏览器环境进行判断，看浏览器是否支持，简化写法如下。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 简化写法\nfunction addEvent (type, el, fn, capture = false) {\n    if (window.addEventListener) {\n        el.addEventListener(type, fn, capture);\n    }\n    else if(window.attachEvent){\n        el.attachEvent('on' + type, fn);\n    }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br")])]),a("p",[n._v("但是这种写法有一个问题，就是每次添加事件都会调用做一次判断，那么有没有什么办法只判断一次呢，可以利用闭包和立即调用函数表达式（IIFE）来处理。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const addEvent = (function(){\n    if (window.addEventListener) {\n        return function (type, el, fn, capture) {\n            el.addEventListener(type, fn, capture);\n        }\n    }\n    else if(window.attachEvent){\n        return function (type, el, fn) {\n            el.attachEvent('on' + type, fn);\n        }\n    }\n})();\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br")])]),a("p",[n._v("上面这种实现方案就是一种典型的柯里化应用，在第一次的 if...else if... 判断之后完成部分计算，动态创建新的函数用于处理后续传入的参数，这样做的好处就是之后调用就不需要再次计算了。")]),n._v(" "),a("p",[n._v("当然可以使用惰性函数来实现这一功能，原理很简单，就是重写函数。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function addEvent (type, el, fn, capture = false) {\n  \t// 重写函数\n    if (window.addEventListener) {\n        addEvent = function (type, el, fn, capture) {\n            el.addEventListener(type, fn, capture);\n        }\n    }\n    else if(window.attachEvent){\n        addEvent = function (type, el, fn) {\n            el.attachEvent('on' + type, fn);\n        }\n    }\n  \t// 执行函数，有循环爆栈风险\n  \taddEvent(type, el, fn, capture); \n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br")])]),a("p",[n._v("第一次调用 addEvent 函数后，会进行一次环境判断，在这之后 addEvent 函数被重写，所以下次调用时就不会再次判断环境，可以说很完美了。")]),n._v(" "),a("h3",{attrs:{id:"_3、参数复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、参数复用"}},[n._v("#")]),n._v(" 3、参数复用")]),n._v(" "),a("p",[n._v("我们知道调用 toString() 可以获取每个对象的类型，但是不同对象的 toString() 有不同的实现，所以需要通过 Object.prototype.toString() 来获取 Object 上的实现，同时以 call() / apply() 的形式来调用，并传递要检查的对象作为第一个参数，例如下面这个例子。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function isArray(obj) { \n    return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction isNumber(obj) {\n    return Object.prototype.toString.call(obj) === '[object Number]';\n}\n\nfunction isString(obj) {\n    return Object.prototype.toString.call(obj) === '[object String]';\n}\n\n// Test\nisArray([1, 2, 3]); // true\nisNumber(123); // true\nisString('123'); // true\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br")])]),a("p",[n._v("但是上面方案有一个问题，那就是每种类型都需要定义一个方法，这里我们可以使用 bind 来扩展，优点是可以直接使用改造后的 toStr。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('const toStr = Function.prototype.call.bind(Object.prototype.toString);\n\n// 改造前\n[1, 2, 3].toString(); // "1,2,3"\n\'123\'.toString(); // "123"\n123.toString(); // SyntaxError: Invalid or unexpected token\nObject(123).toString(); // "123"\n\n// 改造后\ntoStr([1, 2, 3]); \t// "[object Array]"\ntoStr(\'123\'); \t\t// "[object String]"\ntoStr(123); \t\t// "[object Number]"\ntoStr(Object(123)); // "[object Number]"\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br")])]),a("p",[n._v("上面例子首先使用 Function.prototype.call 函数指定一个 this 值，然后 .bind 返回一个新的函数，始终将 Object.prototype.toString 设置为传入参数，其实等价于 Object.prototype.toString.call() 。")]),n._v(" "),a("h2",{attrs:{id:"实现-currying-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现-currying-函数"}},[n._v("#")]),n._v(" 实现 currying 函数")]),n._v(" "),a("p",[n._v("我们可以理解所谓的柯里化函数，就是封装「一系列的处理步骤」，通过闭包将参数集中起来计算，最后再把需要处理的参数传进去。那如何实现 currying 函数呢？")]),n._v(" "),a("p",[n._v("实现原理就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面延迟计算部分已经实现了一个简化版的 currying 函数。")]),n._v(" "),a("p",[n._v("下面我们来实现一个更加健壮的的 currying 函数。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// currying\nfunction currying(fn, length) {\n  length = length || fn.length; \t// 注释 1\n  return function (...args) {\t\t\t// 注释 2\n    return args.length >= length\t// 注释 3\n    \t? fn.apply(this, args)\t\t\t// 注释 4\n      : currying(fn.bind(this, ...args), length - args.length) // 注释 5\n  }\n}\n\n// Test\nconst fn = currying(function(a, b, c) {\n    console.log([a, b, c]);\n});\n\nfn("a", "b", "c") // ["a", "b", "c"]\nfn("a", "b")("c") // ["a", "b", "c"]\nfn("a")("b")("c") // ["a", "b", "c"]\nfn("a")("b", "c") // ["a", "b", "c"]\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br")])]),a("p",[n._v("注释 1：第一次调用获取函数 fn 参数的长度，后续调用获取 fn 剩余参数的长度")]),n._v(" "),a("p",[n._v("注释 2：currying 包裹之后返回一个新函数，接收参数为 ...args")]),n._v(" "),a("p",[n._v("注释 3：新函数接收的参数长度是否大于等于 fn 剩余参数需要接收的长度")]),n._v(" "),a("p",[n._v("注释 4：满足要求，执行 fn 函数，传入新函数的参数")]),n._v(" "),a("p",[n._v("注释 5：不满足要求，递归 currying 函数，新的 fn 为 bind 返回的新函数（bind 绑定了 ...args 参数，未执行），新的 length 为 fn 剩余参数的长度")]),n._v(" "),a("p",[n._v("上面使用的是 ES5 和 ES6 的混合语法，那我不想使用 call/apply/bind 这些方法呢，自然是可以的，看下面的 ES6 极简写法，更加简洁也更加易懂。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 参考自 segmentfault 的@大笑平 \nconst currying = fn =>\n    judge = (...args) =>\n        args.length >= fn.length\n            ? fn(...args)\n            : (...arg) => judge(...args, ...arg)\n\n// Test\nconst fn = currying(function(a, b, c) {\n    console.log([a, b, c]);\n});\n\nfn("a", "b", "c") // ["a", "b", "c"]\nfn("a", "b")("c") // ["a", "b", "c"]\nfn("a")("b")("c") // ["a", "b", "c"]\nfn("a")("b", "c") // ["a", "b", "c"]\n\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br")])]),a("p",[n._v("如果你还无法理解，看完下面例子你就更加容易理解了，要求实现一个 add 方法，需要满足如下预期。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("add(1, 2, 3) // 6\nadd(1, 2)(3) // 6\nadd(1)(2)(3) // 6\nadd(1)(2, 3) // 6\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br")])]),a("p",[n._v("我们可以看到，计算结果就是所有参数的和，如果我们分两次调用时 add(1)(2)，可以写出如下代码。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function add(a) {\n  return function(b) {\n  \treturn a + b;\n  }\n}\n\nadd(1)(2) // 3\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[n._v("add 方法第一次调用后返回一个新函数，通过闭包保存之前的参数，第二次调用时满足参数长度要求然后执行函数。")]),n._v(" "),a("p",[n._v("如果分三次调用时 add(1)(2)(3)，可以写出如下代码。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function add(a) {\n  return function(b) {\n    return function (c) {\n    \treturn a + b + c;\n    }\n  }\n}\nconsole.log(add(1)(2)(3)); // 6\n\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br")])]),a("p",[n._v("前面两次调用每次返回一个新函数，第三次调用后满足参数长度要求然后执行函数。")]),n._v(" "),a("p",[n._v("这时候我们再来看 currying 实现函数，其实就是判断当前参数长度够不够，参数够了就立马执行，不够就返回一个新函数，这个新函数并不执行，并且通过 bind 或者闭包保存之前传入的参数。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 注释同上\nfunction currying(fn, length) {\n  length = length || fn.length; \t\n  return function (...args) {\t\t\t\n    return args.length >= length\t\n    \t? fn.apply(this, args)\t\t\t\n      : currying(fn.bind(this, ...args), length - args.length) \n  }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br")])]),a("h2",{attrs:{id:"扩展-函数参数-length"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展-函数参数-length"}},[n._v("#")]),n._v(" 扩展：函数参数 length")]),n._v(" "),a("p",[n._v("函数 currying 的实现中，使用了 fn.length 来表示函数参数的个数，那 fn.length 表示函数的所有参数个数吗？并不是。")]),n._v(" "),a("p",[n._v("函数的 length 属性获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数，看下面的例子。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("((a, b, c) => {}).length; \n// 3\n\n((a, b, c = 3) => {}).length; \n// 2 \n\n((a, b = 2, c) => {}).length; \n// 1 \n\n((a = 1, b, c) => {}).length; \n// 0 \n\n((...args) => {}).length; \n// 0\n\nconst fn = (...args) => {\n  console.log(args.length);\n} \nfn(1, 2, 3)\n// 3\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br")])]),a("p",[n._v("所以在柯里化的场景中，不建议使用 ES6 的函数参数默认值。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const fn = currying((a = 1, b, c) => {\n  console.log([a, b, c]); \n}); \n\nfn();\n// [1, undefined, undefined]\n\nfn()(2)(3); \n// Uncaught TypeError: fn(...) is not a function\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br")])]),a("p",[n._v("我们期望函数 fn 输出 [1, 2, 3]，但是实际上调用柯里化函数时 ((a = 1, b, c) => {}).length === 0，所以调用 fn() 时就已经执行并输出了 [1, undefined, undefined]，而不是理想中的返回闭包函数，所以后续调用 fn()(2)(3) 将会报错。")]),n._v(" "),a("h3",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[n._v("#")]),n._v(" 参考文章")]),n._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/42",target:"_blank",rel:"noopener noreferrer"}},[n._v("JavaScript 专题之函数柯里化"),a("OutboundLink")],1),a("br"),n._v(" "),a("a",{attrs:{href:"https://www.zhihu.com/question/37774367/answer/192978122",target:"_blank",rel:"noopener noreferrer"}},[n._v("柯里化在工程中有什么好处? "),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);