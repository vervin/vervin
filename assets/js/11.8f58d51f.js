(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{591:function(s,a,n){s.exports=n.p+"assets/img/fc.651f4c36.jpg"},592:function(s,a,n){s.exports=n.p+"assets/img/bg2017022204.9dc550d6.png"},593:function(s,a,n){s.exports=n.p+"assets/img/bg2017022209.6909477e.png"},615:function(s,a,n){"use strict";n.r(a);var t=n(8),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"范畴论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范畴论"}},[s._v("#")]),s._v(" 范畴论")]),s._v(" "),t("h3",{attrs:{id:"范畴的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范畴的概念"}},[s._v("#")]),s._v(" 范畴的概念")]),s._v(" "),t("p",[s._v("什么是范畴呢？")]),s._v(" "),t("blockquote",[t("p",[s._v('"范畴就是使用箭头连接的物体。"（In mathematics, a category is an algebraic structure that comprises "objects" that are linked by "arrows". ）')])]),s._v(" "),t("p",[s._v('也就是说，彼此之间存在某种关系的概念、事物、对象等等，都构成"范畴"。随便什么东西，只要能找出它们之间的关系，就能定义一个"范畴"。\n')]),s._v(" "),t("p",[t("img",{attrs:{src:n(591),alt:"category"}})]),s._v(" "),t("p",[s._v("上图中，各个点与它们之间的箭头，就构成一个范畴。")]),s._v(" "),t("p",[s._v('箭头表示范畴成员之间的关系，正式的名称叫做"态射"（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的"变形"（transformation）。通过"态射"，一个成员可以变形成另一个成员。')]),s._v(" "),t("h3",{attrs:{id:"数学模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数学模型"}},[s._v("#")]),s._v(" 数学模型")]),s._v(" "),t("p",[s._v('既然"范畴"是满足某种变形关系的所有对象，就可以总结出它的数学模型。')]),s._v(" "),t("blockquote",[t("ul",[t("li",[s._v("所有成员是一个集合")]),s._v(" "),t("li",[s._v("变形关系是函数")])])]),s._v(" "),t("p",[s._v('也就是说，范畴论是集合论更上层的抽象，简单的理解就是"集合 + 函数"。')]),s._v(" "),t("p",[s._v("理论上通过函数，就可以从范畴的一个成员，算出其他所有成员。")]),s._v(" "),t("h3",{attrs:{id:"范畴与容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范畴与容器"}},[s._v("#")]),s._v(" 范畴与容器")]),s._v(" "),t("p",[s._v('我们可以把"范畴"想象成是一个容器，里面包含两样东西。')]),s._v(" "),t("blockquote",[t("ul",[t("li",[s._v("值（value）")]),s._v(" "),t("li",[s._v("值的变形关系，也就是函数。")])])]),s._v(" "),t("p",[s._v("下面我们使用代码，定义一个简单的范畴。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Category {\n  constructor(val) { \n    this.val = val; \n  }\n\n  addOne(x) {\n    return x + 1;\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[s._v("上面代码中，Category是一个类，也是一个容器，里面包含一个值（this.val）和一种变形关系（addOne）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。")]),s._v(" "),t("p",[s._v('注意，本文后面的部分，凡是提到"容器"的地方，全部都是指"范畴"。')]),s._v(" "),t("h3",{attrs:{id:"范畴论与函数式编程的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范畴论与函数式编程的关系"}},[s._v("#")]),s._v(" 范畴论与函数式编程的关系")]),s._v(" "),t("p",[s._v("范畴论使用函数，表达范畴之间的关系。")]),s._v(" "),t("p",[s._v('伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的"函数式编程"。')]),s._v(" "),t("p",[t("strong",[s._v("==本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。==")])]),s._v(" "),t("p",[s._v("所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。")]),s._v(" "),t("p",[t("strong",[s._v("==总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。==")])]),s._v(" "),t("h2",{attrs:{id:"函数的合成与柯里化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数的合成与柯里化"}},[s._v("#")]),s._v(" 函数的合成与柯里化")]),s._v(" "),t("p",[s._v("函数式编程有两个最基本的运算：合成和柯里化。")]),s._v(" "),t("h3",{attrs:{id:"函数的合成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数的合成"}},[s._v("#")]),s._v(" 函数的合成")]),s._v(" "),t("p",[s._v('如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做"函数的合成"（compose）。')]),s._v(" "),t("p",[t("img",{attrs:{src:n(592),alt:"函数的合成"}})]),s._v(" "),t("p",[s._v("上图中，==X==和==Y==之间的变形关系是函数==f==，==Y==和==Z==之间的变形关系是函数==g==，那么==X==和==Z==之间的关系，就是g和f的合成函数==g·f==。")]),s._v(" "),t("p",[s._v("合成两个函数的简单代码如下。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("const compose = function (f, g) {\n  return function (x) {\n    return f(g(x));\n  };\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("函数的合成还必须满足结合律。\n"),t("img",{attrs:{src:n(593),alt:"结合律"}})]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("compose(f, compose(g, h))\n// 等同于\ncompose(compose(f, g), h)\n// 等同于\ncompose(f, g, h)\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？")]),s._v(" "),t("p",[s._v("前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。")]),s._v(" "),t("h3",{attrs:{id:"柯里化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[s._v("#")]),s._v(" 柯里化")]),s._v(" "),t("p",[s._v("f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。")]),s._v(" "),t("p",[s._v('这时就需要函数柯里化了。所谓"柯里化"，就是把一个多参数的函数，转化为单参数函数。')]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// 柯里化之前\nfunction add(x, y) {\n  return x + y;\n}\n\nadd(1, 2) // 3\n\n// 柯里化之后\nfunction addX(y) {\n  return function (x) {\n    return x + y;\n  };\n}\n\naddX(2)(1) // 3\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])]),t("p",[s._v("有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。")]),s._v(" "),t("h2",{attrs:{id:"函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函子"}},[s._v("#")]),s._v(" 函子")]),s._v(" "),t("p",[s._v("函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。")]),s._v(" "),t("h3",{attrs:{id:"函子的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函子的概念"}},[s._v("#")]),s._v(" 函子的概念")]),s._v(" "),t("p",[s._v("函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。")]),s._v(" "),t("p",[s._v("它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。"),t("strong",[s._v("比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。")])]),s._v(" "),t("h3",{attrs:{id:"函子的代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函子的代码实现"}},[s._v("#")]),s._v(" 函子的代码实现")]),s._v(" "),t("p",[s._v("任何具有map方法的数据结构，都可以当作函子的实现。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Functor {\n  constructor(val) { \n    this.val = val; \n  }\n\n  map(f) {\n    return new Functor(f(this.val));\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[s._v("上面代码中，Functor是一个函子，它的map方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（f(this.val)）。")]),s._v(" "),t("p",[t("strong",[s._v("一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。")])]),s._v(" "),t("p",[s._v("下面是一些用法的示例。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("(new Functor(2)).map(function (two) {\n  return two + 2;\n});\n// Functor(4)\n\n(new Functor('flamethrowers')).map(function(s) {\n  return s.toUpperCase();\n});\n// Functor('FLAMETHROWERS')\n\n(new Functor('bombs')).map(_.concat(' away')).map(_.prop('length'));\n// Functor(10)\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("p",[s._v("上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。")]),s._v(" "),t("p",[s._v("因此，学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。")]),s._v(" "),t("h2",{attrs:{id:"of-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#of-方法"}},[s._v("#")]),s._v(" of 方法")]),s._v(" "),t("p",[s._v("你可能注意到了，上面生成新的函子的时候，用了new命令。这实在太不像函数式编程了，因为new命令是面向对象编程的标志。")]),s._v(" "),t("p",[s._v("函数式编程一般约定，函子有一个of方法，用来生成新的容器。")]),s._v(" "),t("p",[s._v("下面就用of方法替换掉new。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Functor.of = function(val) {\n  return new Functor(val);\n};\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("然后，前面的例子就可以改成下面这样。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Functor.of(2).map(function (two) {\n  return two + 2;\n});\n// Functor(4)\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("这就更像函数式编程了。")]),s._v(" "),t("h2",{attrs:{id:"maybe-函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#maybe-函子"}},[s._v("#")]),s._v(" Maybe 函子")]),s._v(" "),t("p",[s._v("函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Functor.of(null).map(function (s) {\n  return s.toUpperCase();\n});\n// TypeError\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("上面代码中，函子里面的值是null，结果小写变成大写的时候就出错了。")]),s._v(" "),t("p",[s._v("Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Maybe extends Functor {\n  map(f) {\n    return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("有了 Maybe 函子，处理空值就不会出错了。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Maybe.of(null).map(function (s) {\n  return s.toUpperCase();\n});\n// Maybe(null)\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h2",{attrs:{id:"either-函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#either-函子"}},[s._v("#")]),s._v(" Either 函子")]),s._v(" "),t("p",[s._v("条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。")]),s._v(" "),t("p",[s._v("Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Either extends Functor {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n  }\n\n  map(f) {\n    return this.right ? \n      Either.of(this.left, f(this.right)) :\n      Either.of(f(this.left), this.right);\n  }\n}\n\nEither.of = function (left, right) {\n  return new Either(left, right);\n};\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br")])]),t("p",[s._v("下面是用法。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var addOne = function (x) {\n  return x + 1;\n};\n\nEither.of(5, 6).map(addOne);\n// Either(5, 7);\n\nEither.of(1, null).map(addOne);\n// Either(2, null);\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("p",[s._v("上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。")]),s._v(" "),t("p",[s._v("Either 函子的常见用途是提供默认值。下面是一个例子。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Either\n.of({address: 'xxx'}, currentUser.address)\n.map(updateField);\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。")]),s._v(" "),t("p",[s._v("Either 函子的另一个用途是代替try...catch，使用左值表示错误。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("function parseJSON(json) {\n  try {\n    return Either.of(null, JSON.parse(json));\n  } catch (e: Error) {\n    return Either.of(e, null);\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("p",[s._v("上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象e。一般来说，所有可能出错的运算，都可以返回一个 Either 函子。")]),s._v(" "),t("h2",{attrs:{id:"ap-函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ap-函子"}},[s._v("#")]),s._v(" ap 函子")]),s._v(" "),t("p",[s._v("函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。")]),s._v(" "),t("p",[s._v("function addTwo(x) {\nreturn x + 2;\n}")]),s._v(" "),t("p",[s._v("const A = Functor.of(2);\nconst B = Functor.of(addTwo)\n上面代码中，函子A内部的值是2，函子B内部的值是函数addTwo。")]),s._v(" "),t("p",[s._v("有时，我们想让函子B内部的函数，可以使用函子A内部的值进行运算。这时就需要用到 ap 函子。")]),s._v(" "),t("p",[s._v("ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Ap extends Functor {\n  ap(F) {\n    return Ap.of(this.val(F.val));\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("注意，ap方法的参数不是函数，而是另一个函子。")]),s._v(" "),t("p",[s._v("因此，前面例子可以写成下面的形式。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Ap.of(addTwo).ap(Functor.of(2))\n// Ap(4)\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("function add(x) {\n  return function (y) {\n    return x + y;\n  };\n}\n\nAp.of(add).ap(Maybe.of(2)).ap(Maybe.of(3));\n// Ap(5)\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("上面代码中，函数add是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Ap.of(add(2)).ap(Maybe.of(3));\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("八、Monad 函子\n函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。")]),s._v(" "),t("p",[s._v("Maybe.of(\nMaybe.of(\nMaybe.of({name: 'Mulburry', number: 8402})\n)\n)\n上面这个函子，一共有三个Maybe嵌套。如果要取出内部的值，就要连续取三次this.val。这当然很不方便，因此就出现了 Monad 函子。")]),s._v(" "),t("p",[s._v("Monad 函子的作用是，总是返回一个单层的函子。它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Monad extends Functor {\n  join() {\n    return this.val;\n  }\n  flatMap(f) {\n    return this.map(f).join();\n  }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("上面代码中，如果函数f返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，join方法保证了flatMap方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。")]),s._v(" "),t("h2",{attrs:{id:"io-操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io-操作"}},[s._v("#")]),s._v(" IO 操作")]),s._v(" "),t("p",[s._v("Monad 函子的重要应用，就是实现 I/O （输入输出）操作。")]),s._v(" "),t("p",[s._v("I/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成Monad函子，通过它来完成。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var fs = require('fs');\n\nvar readFile = function(filename) {\n  return new IO(function() {\n    return fs.readFileSync(filename, 'utf-8');\n  });\n};\n\nvar print = function(x) {\n  return new IO(function() {\n    console.log(x);\n    return x;\n  });\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br")])]),t("p",[s._v("上面代码中，读取文件和打印本身都是不纯的操作，但是readFile和print却是纯函数，因为它们总是返回 IO 函子。")]),s._v(" "),t("p",[s._v("如果 IO 函子是一个Monad，具有flatMap方法，那么我们就可以像下面这样调用这两个函数。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("readFile('./user.txt')\n.flatMap(print)\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("这就是神奇的地方，上面的代码完成了不纯的操作，但是因为flatMap返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。")]),s._v(" "),t("p",[s._v("由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，flatMap方法被改名成chain。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var tail = function(x) {\n  return new IO(function() {\n    return x[x.length - 1];\n  });\n}\n\nreadFile('./user.txt')\n.flatMap(tail)\n.flatMap(print)\n\n// 等同于\nreadFile('./user.txt')\n.chain(tail)\n.chain(print)\n上面代码读取了文件user.txt，然后选取最后一行输出。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])]),t("h2",{attrs:{id:"参考链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[s._v("#")]),s._v(" 参考链接")]),s._v(" "),t("p",[t("a",{attrs:{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/",target:"_blank",rel:"noopener noreferrer"}},[s._v("JS 函数式编程指南"),t("OutboundLink")],1),t("br"),s._v(" "),t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("函数式编程入门教程"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);